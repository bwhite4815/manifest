{
  "name": "sockjs",
  "author": {
    "name": "Marek Majkowski"
  },
  "version": "0.3.1",
  "description": "SockJS-node is a server counterpart of SockJS-client a JavaScript library that provides a WebSocket-like object in the browser. SockJS gives you a coherent, cross-browser, Javascript API which creates a low latency, full duplex, cross-domain communication channel between the browser and the web server.",
  "keywords": [
    "websockets",
    "websocket"
  ],
  "homepage": "https://github.com/sockjs/sockjs-node",
  "repository": {
    "type": "git",
    "url": "https://github.com/sockjs/sockjs-node.git"
  },
  "dependencies": {
    "node-uuid": "1.3.3",
    "faye-websocket": "0.4.0",
    "rbytes": "0.0.2"
  },
  "optionalDependencies": {
    "rbytes": "0.0.2"
  },
  "devDependencies": {
    "coffee-script": "1.2.x"
  },
  "main": "index",
  "readme": "SockJS family:\r\n\r\n  * [SockJS-client](https://github.com/sockjs/sockjs-client) JavaScript client library\r\n  * [SockJS-node](https://github.com/sockjs/sockjs-node) Node.js server\r\n  * [SockJS-erlang](https://github.com/sockjs/sockjs-erlang) Erlang server\r\n\r\n\r\nSockJS-node server\r\n==================\r\n\r\nSockJS-node is a Node.js server side counterpart of\r\n[SockJS-client browser library](https://github.com/sockjs/sockjs-client)\r\nwritten in CoffeeScript.\r\n\r\nTo install `sockjs-node` run:\r\n\r\n    npm install sockjs\r\n\r\n(If you see `rbytes` dependecy failing, don't worry, it's optional, SockJS-node will work fine without it.)\r\n\r\nAn simplified echo SockJS server could look more or less like:\r\n\r\n```javascript\r\nvar http = require('http');\r\nvar sockjs = require('sockjs');\r\n\r\nvar echo = sockjs.createServer();\r\necho.on('connection', function(conn) {\r\n    conn.on('data', function(message) {\r\n        conn.write(message);\r\n    });\r\n    conn.on('close', function() {});\r\n});\r\n\r\nvar server = http.createServer();\r\necho.installHandlers(server, {prefix:'/echo'});\r\nserver.listen(9999, '0.0.0.0');\r\n```\r\n\r\n(Take look at\r\n[examples](https://github.com/sockjs/sockjs-node/tree/master/examples/echo)\r\ndirectory for a complete version.)\r\n\r\nSubscribe to\r\n[SockJS mailing list](https://groups.google.com/forum/#!forum/sockjs) for\r\ndiscussions and support.\r\n\r\n\r\nLive QUnit tests and smoke tests\r\n--------------------------------\r\n\r\n[SockJS-client](https://github.com/sockjs/sockjs-client) comes with\r\nsome QUnit tests and a few smoke tests that are using SockJS-node. At\r\nthe moment they are deployed in few places, just click to see if\r\nSockJS is working in your browser:\r\n\r\n * http://sockjs.popcnt.org/ and https://sockjs.popcnt.org/ (hosted in Europe)\r\n * http://sockjs.cloudfoundry.com/ (CloudFoundry, websockets disabled, loadbalanced)\r\n * https://sockjs.cloudfoundry.com/ (CloudFoundry SSL, websockets disabled, loadbalanced)\r\n\r\n\r\nSockJS-node API\r\n---------------\r\n\r\nThe API design is based on the common Node API's like\r\n[Streams API](http://nodejs.org/docs/v0.5.8/api/streams.html) or\r\n[Http.Server API](http://nodejs.org/docs/v0.5.8/api/http.html#http.Server).\r\n\r\n### Server class\r\n\r\nSockJS module is generating a `Server` class, similar to\r\n[Node.js http.createServer](http://nodejs.org/docs/v0.5.8/api/http.html#http.createServer)\r\nmodule.\r\n\r\n```javascript\r\nvar sockjs_server = sockjs.createServer(options);\r\n```\r\n\r\nWhere `options` is a hash which can contain:\r\n\r\n<dl>\r\n<dt>sockjs_url (string, required)</dt>\r\n<dd>Transports which don't support cross-domain communication natively\r\n   ('eventsource' to name one) use an iframe trick. A simple page is\r\n   served from the SockJS server (using its foreign domain) and is\r\n   placed in an invisible iframe. Code run from this iframe doesn't\r\n   need to worry about cross-domain issues, as it's being run from\r\n   domain local to the SockJS server. This iframe also does need to\r\n   load SockJS javascript client library, and this option lets you specify\r\n   its url (if you're unsure, point it to\r\n   <a href=\"http://cdn.sockjs.org/sockjs-0.3.min.js\">\r\n   the latest minified SockJS client release</a>, this is the default).\r\n   You must explicitly specify this url on the server side for security\r\n   reasons - we don't want the possibility of running any foreign\r\n   javascript within the SockJS domain (aka cross site scripting attack).\r\n   Also, sockjs javascript library is probably already cached by the\r\n   browser - it makes sense to reuse the sockjs url you're using in\r\n   normally.</dd>\r\n\r\n<dt>prefix (string)</dt>\r\n<dd>A url prefix for the server. All http requests which paths begins\r\n   with selected prefix will be handled by SockJS. All other requests\r\n   will be passed through, to previously registered handlers.</dd>\r\n\r\n<dt>response_limit (integer)</dt>\r\n<dd>Most streaming transports save responses on the client side and\r\n   don't free memory used by delivered messages. Such transports need\r\n   to be garbage-collected once in a while. `response_limit` sets\r\n   a minimum number of bytes that can be send over a single http streaming\r\n   request before it will be closed. After that client needs to open\r\n   new request. Setting this value to one effectively disables\r\n   streaming and will make streaming transports to behave like polling\r\n   transports. The default value is 128K.</dd>\r\n\r\n<dt>websocket (boolean)</dt>\r\n<dd>Some load balancers don't support websockets. This option can be used\r\n   to disable websockets support by the server. By default websockets are\r\n   enabled.</dd>\r\n\r\n<dt>jsessionid (boolean or function)</dt>\r\n<dd>Some hosting providers enable sticky sessions only to requests that\r\n  have JSESSIONID cookie set. This setting controls if the server should\r\n  set this cookie to a dummy value. By default setting JSESSIONID cookie\r\n  is disabled. More sophisticated beaviour can be achieved by supplying\r\n  a function.</dd>\r\n\r\n<dt>log (function(severity, message))</dt>\r\n<dd>It's quite useful, especially for debugging, to see some messages\r\n  printed by a SockJS-node library. This is done using this `log`\r\n  function, which is by default set to `console.log`. If this\r\n  behaviour annoys you for some reason, override `log` setting with a\r\n  custom handler.  The following `severities` are used: `debug`\r\n  (miscellaneous logs), `info` (requests logs), `error` (serious\r\n  errors, consider filing an issue).</dd>\r\n\r\n<dt>heartbeat_delay (milliseconds)</dt>\r\n<dd>In order to keep proxies and load balancers from closing long\r\n  running http requests we need to pretend that the connecion is\r\n  active and send a heartbeat packet once in a while. This setting\r\n  controlls how often this is done. By default a heartbeat packet is\r\n  sent every 25 seconds.  </dd>\r\n\r\n<dt>disconnect_delay (milliseconds)</dt>\r\n<dd>The server sends a `close` event when a client receiving\r\n  connection have not been seen for a while. This delay is configured\r\n  by this setting. By default the `close` event will be emitted when a\r\n  receiving connection wasn't seen for 5 seconds.  </dd>\r\n</dl>\r\n\r\n\r\n### Server instance\r\n\r\nOnce you have create `Server` instance you can hook it to the\r\n[http.Server instance](http://nodejs.org/docs/v0.5.8/api/http.html#http.createServer).\r\n\r\n```javascript\r\nvar http_server = http.createServer();\r\nsockjs_server.installHandlers(http_server, options);\r\nhttp_server.listen(...);\r\n```\r\n\r\nWhere `options` can overshadow options given when creating `Server`\r\ninstance.\r\n\r\n`Server` instance is an\r\n[EventEmitter](http://nodejs.org/docs/v0.4.10/api/events.html#events.EventEmitter),\r\nand emits following event:\r\n\r\n<dl>\r\n<dt>Event: connection (connection)</dt>\r\n<dd>A new connection has been successfully opened.</dd>\r\n</dl>\r\n\r\nAll http requests that don't go under the path selected by `prefix`\r\nwill remain unanswered and will be passed to previously registered\r\nhandlers. You must install your custom http handlers before calling\r\n`installHandlers`.\r\n\r\n### Connection instance\r\n\r\nA `Connection` instance supports\r\n[Node Stream API](http://nodejs.org/docs/v0.5.8/api/streams.html) and\r\nhas following methods and properties:\r\n\r\n<dl>\r\n<dt>Property: readable (boolean)</dt>\r\n<dd>Is the stream readable?</dd>\r\n\r\n<dt>Property: writable (boolean)</dt>\r\n<dd>Is the stream writable?</dd>\r\n\r\n<dt>Property: remoteAddress (string)</dt>\r\n<dd>Last known IP address of the client.</dd>\r\n\r\n<dt>Property: remotePort (number)</dt>\r\n<dd>Last known port number of the client.</dd>\r\n\r\n<dt>Property: address (object)</dt>\r\n<dd>Hash with 'address' and 'port' fields.</dd>\r\n\r\n<dt>Property: headers (object)</dt>\r\n<dd>Hash containing various headers copied from last receiving request\r\n    on that connection. Exposed headers include: `origin`, `referer`\r\n    and `x-forwarded-for` (and friends). We expliclty do not grant\r\n    access to `cookie` header, as using it may easily lead to security\r\n    issues (for details read the section \"Authorization\").</dd>\r\n\r\n<dt>Property: url (string)</dt>\r\n<dd><a href=\"http://nodejs.org/docs/v0.4.10/api/http.html#request.url\">Url</a>\r\n    property copied from last request.</dd>\r\n\r\n<dt>Property: pathname (string)</dt>\r\n<dd>`pathname` from parsed url, for convenience.</dd>\r\n\r\n<dt>Property: prefix (string)</dt>\r\n<dd>Prefix of the url on which the request was handled.</dd>\r\n\r\n<dt>Property: protocol (string)</dt>\r\n<dd>Protocol used by the connection. Keep in mind that some protocols\r\n   are indistinguishable - for example \"xhr-polling\" and \"xdr-polling\".</dd>\r\n\r\n<dt>Property: readyState (integer)</dt>\r\n<dd>Current state of the connection:\r\n   0-connecting, 1-open, 2-closing, 3-closed.</dd>\r\n\r\n<dt>write(message)</dt>\r\n<dd>Sends a message over opened connection. A message must be a\r\n  non-empty string. It's illegal to send a message after the connection was\r\n  closed (either after 'close' or 'end' method or 'close' event).</dd>\r\n\r\n<dt>close([code], [reason])</dt>\r\n<dd>Asks the remote client to disconnect. 'code' and 'reason'\r\n   parameters are optional and can be used to share the reason of\r\n   disconnection.</dd>\r\n\r\n<dt>end()</dt>\r\n<dd>Asks the remote client to disconnect with default 'code' and\r\n   'reason' values.</dd>\r\n\r\n</dl>\r\n\r\nA `Connection` instance emits the following events:\r\n\r\n<dl>\r\n<dt>Event: data (message)</dt>\r\n<dd>A message arrived on the connection. Message is a unicode\r\n  string.</dd>\r\n\r\n<dt>Event: close ()</dt>\r\n<dd>Connection was closed. This event is triggered exactly once for\r\n   every connection.</dd>\r\n</dl>\r\n\r\nFor example:\r\n\r\n```javascript\r\nsockjs_server.on('connection', function(conn) {\r\n    console.log('connection' + conn);\r\n    conn.on('close', function() {\r\n        console.log('close ' + conn);\r\n    });\r\n    conn.on('data', function(message) {\r\n        console.log('message ' + conn,\r\n                    message);\r\n    });\r\n});\r\n```\r\n\r\n### Footnote\r\n\r\nA fully working echo server does need a bit more boilerplate (to\r\nhandle requests unanswered by SockJS), see the\r\n[`echo` example](https://github.com/sockjs/sockjs-node/tree/master/examples/echo)\r\nfor a complete code.\r\n\r\n### Examples\r\n\r\nIf you want to see samples of running code, take a look at:\r\n\r\n * [./examples/echo](https://github.com/sockjs/sockjs-node/tree/master/examples/echo)\r\n   directory, which contains a full example of a echo server.\r\n * [./examples/test_server](https://github.com/sockjs/sockjs-node/tree/master/examples/test_server) a standard SockJS test server.\r\n\r\n\r\nConnecting to SockJS-node without the client\r\n--------------------------------------------\r\n\r\nAlthough the main point of SockJS it to enable browser-to-server\r\nconnectivity, it is possible to connect to SockJS from an external\r\napplication. Any SockJS server complying with 0.3 protocol does\r\nsupport a raw WebSocket url. The raw WebSocket url for the test server\r\nlooks like:\r\n\r\n * ws://localhost:8081/echo/websocket\r\n\r\nYou can connect any WebSocket RFC 6455 compliant WebSocket client to\r\nthis url. This can be a command line client, external application,\r\nthird party code or even a browser (though I don't know why you would\r\nwant to do so).\r\n\r\n\r\nDeployment and load balancing\r\n-----------------------------\r\n\r\nThere are two issues that needs to be considered when planning a\r\nnon-trivial SockJS-node deployment: WebSocket-compatible load balancer\r\nand sticky sessions (aka session affinity).\r\n\r\n### WebSocket compatible load balancer\r\n\r\nOften WebSockets don't play nicely with proxies and load balancers.\r\nDeploying a SockJS server behind Nginx or Apache could be painful.\r\n\r\nFortunetely recent versions of an excellent load balancer\r\n[HAProxy](http://haproxy.1wt.eu/) are able to proxy WebSocket\r\nconnections. We propose to put HAProxy as a front line load balancer\r\nand use it to split SockJS traffic from normal HTTP data. Take a look\r\nat the sample\r\n[SockJS HAProxy configuration](https://github.com/sockjs/sockjs-node/blob/master/examples/haproxy.cfg).\r\n\r\nThe config also shows how to use HAproxy balancing to split traffic\r\nbetween multiple Node.js servers. You can also do balancing using dns\r\nnames.\r\n\r\n### Sticky sessions\r\n\r\nIf you plan depling more than one SockJS server, you must make sure\r\nthat all HTTP requests for a single session will hit the same server.\r\nSockJS has two mechanisms that can be usefull to achieve that:\r\n\r\n * Urls are prefixed with server and session id numbers, like:\r\n   `/resource/<server_number>/<session_id>/transport`.  This is\r\n   usefull for load balancers that support prefix-based affinity\r\n   (HAProxy does).\r\n * `JSESSIONID` cookie is being set by SockJS-node. Many load\r\n   balancers turn on sticky sessions if that cookie is set. This\r\n   technique is derived from Java applications, where sticky sessions\r\n   are often neccesary. HAProxy does support this method, as well as\r\n   some hosting providers, for example CloudFoundry.  In order to\r\n   enable this method on the client side, please supply a\r\n   `cookie:true` option to SockJS constructor.\r\n\r\n\r\nDevelopment and testing\r\n-----------------------\r\n\r\nIf you want to work on SockJS-node source code, you need to clone the\r\ngit repo and follow these steps. First you need to install\r\ndependencies:\r\n\r\n    cd sockjs-node\r\n    npm install --dev\r\n    ln -s .. node_modules/sockjs\r\n\r\nYou're ready to compile CoffeeScript:\r\n\r\n    make build\r\n\r\nIf compilation succeeds you may want to test if your changes pass all\r\nthe tests. Currently, there are two separate test suites. For both of\r\nthem you need to start a SockJS-node test server (by default listening\r\non port 8081):\r\n\r\n    make test_server\r\n\r\n### SockJS-protocol Python tests\r\n\r\nTo run it run something like:\r\n\r\n    cd sockjs-protocol\r\n    make test_deps\r\n    ./venv/bin/python sockjs-protocol-0.3.py\r\n\r\nFor details see\r\n[SockJS-protocol README](https://github.com/sockjs/sockjs-protocol#readme).\r\n\r\n### SockJS-client QUnit tests\r\n\r\nYou need to start a second web server (by default listening on 8080)\r\nthat is serving various static html and javascript files:\r\n\r\n    cd sockjs-client\r\n    make test\r\n\r\nAt that point you should have two web servers running: sockjs-node on\r\n8081 and sockjs-client on 8080. When you open the browser on\r\n[http://localhost:8080/](http://localhost:8080/) you should be able\r\nrun the QUnit tests against your sockjs-node server.\r\n\r\nFor details see\r\n[SockJS-client README](https://github.com/sockjs/sockjs-client#readme).\r\n\r\nAdditionally, if you're doing more serious development consider using\r\n`make serve`, which will automatically the server when you modify the\r\nsource code.\r\n\r\n\r\nVarious issues and design considerations\r\n----------------------------------------\r\n\r\n### Authorization\r\n\r\nSockJS-node does not expose cookies to the application. This is done\r\ndeliberately as using cookie-based authorization with SockJS simply\r\ndoesn't make sense and will lead to security issues.\r\n\r\nCookies are a contract between a browser and an http server, and are\r\nidentified by a domain name. If a browser has a cookie set for\r\nparticular domain, it will pass it as a part of all http requests to\r\nthe host. But to get various transports working, SockJS uses a middleman\r\n- an iframe hosted from target SockJS domain. That means the server\r\nwill receive requests from the iframe, and not from the real\r\ndomain. The domain of an iframe is the same as the SockJS domain. The\r\nproblem is that any website can embedd the iframe and communicate with\r\nit - and request establishing SockJS connection. Using cookies for\r\nauthorization in this scenario will result in granting full access to\r\nSockJS communication with your website from any website. This is a\r\nclassic CSRF attack.\r\n\r\nBasically - cookies are not suited for SockJS model. If you want to\r\nauthorize a session - provide a unique token on a page, send it as a\r\nfirst thing over SockJS connection and validate it on the server\r\nside. In essence, this is how cookies work.\r\n\r\n\r\n### Deploying SockJS on Heroku\r\n\r\nLong polling is known to cause problems on Heroku, but\r\n[workaround for SockJS is available](https://github.com/sockjs/sockjs-node/issues/57#issuecomment-5242187).\r\n",
  "readmeFilename": "README.md",
  "_id": "sockjs@0.3.1",
  "dist": {
    "shasum": "3fd1cf212e6124eda68cb1fec4f0f36ee3603f77"
  },
  "_resolved": "git://github.com/substack/sockjs-node.git#49090a1212ba2e7216c1cf36415de3c5c74e1901",
  "_from": "sockjs@git://github.com/substack/sockjs-node.git#npm"
}
